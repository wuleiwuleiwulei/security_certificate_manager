/*
 * Copyright (c) 2025-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BusinessError, AsyncCallback } from '@ohos.base';

native function installPrivateCertificateNative(keystore: ArrayBuffer, keystorePwd: string,
  certAlias: string): NativeResult<certificateManager.CMResult>;

native function uninstallPrivateCertificateNative(keyUri: string): NativeResult<void>;

native function getAllAppPrivateCertificatesNative(): NativeResult<certificateManager.CMResult>;

native function getAllAppPrivateCertificatesByUidNative(appUid: int): NativeResult<certificateManager.CMResult>;

native function getPrivateCertificateNative(keyUri: string): NativeResult<certificateManager.CMResult>;

native function initNative(authUri: string,
  spec: certificateManager.CMSignatureSpec): NativeResult<certificateManager.CMHandle>;

native function updateNative(handle: ArrayBuffer, data: ArrayBuffer): NativeResult<void>;

native function signatureFinishNative(handle: ArrayBuffer): NativeResult<certificateManager.CMResult>;

native function verifyFinishNative(handle: ArrayBuffer, signature: ArrayBuffer): NativeResult<certificateManager.CMResult>;

native function abortNative(handle: ArrayBuffer): NativeResult<void>;

native function getPublicCertificateNative(keyUri: string): NativeResult<certificateManager.CMResult>;

native function isAuthorizedAppNative(keyUri: string): NativeResult<boolean>;

native function getAllUserCANative(): NativeResult<certificateManager.CMResult>;

native function getAllUserCAByScopeNative(
  scope: certificateManager.CertScope
): NativeResult<certificateManager.CMResult>;

native function getUserCANative(certUri: string): NativeResult<certificateManager.CMResult>;

native function getAllSystemCredNative(): NativeResult<certificateManager.CMResult>;

native function getPrivateCertificatesNative(): NativeResult<certificateManager.CMResult>;

native function getCertificateStorePathNative(
  certType: certificateManager.CertType,
  certScope: certificateManager.CertScope,
  certAlg: certificateManager.CertAlgorithm
): NativeResult<string>;

native function installUserCASyncNative(
  cert: ArrayBuffer,
  certScope: certificateManager.CertScope
): NativeResult<certificateManager.CMResult>;

native function uninstallUserCASyncNative(certUri: string): NativeResult<void>;

native function installPrivateCertWithLevelNative(
  keystore: ArrayBuffer,
  keystorePwd: string,
  certAlias: string,
  level: certificateManager.AuthStorageLevel
): NativeResult<certificateManager.CMResult>;

native function getUkeyCertificateListNative(
  ukeyProvider: string,
  certPurpose: certificateManager.CertificatePurpose
): NativeResult<certificateManager.CMResult>;

native function getUkeyCertificateNative(
  keyUri: string,
  certPurpose: certificateManager.CertificatePurpose
): NativeResult<certificateManager.CMResult>;

class NativeResult<T> {
  code: int;
  message: string = "";
  result?: T;
}

class CredentialAbstractClass implements certificateManager.CredentialAbstract {
  type: string = '';
  alias: string = '';
  keyUri: string = '';
}

class CMResultClass implements certificateManager.CMResult{
  certList?: Array<certificateManager.CertAbstract>;
  certInfo?: certificateManager.CertInfo;
  credentialList?: Array<certificateManager.CredentialAbstract>;
  credential?: certificateManager.Credential;
  appUidList?: Array<string>;
  uri?: string;
  outData?: Uint8Array;
  credentialDetailList?: Array<certificateManager.Credential>;
}

class CredentialClass implements certificateManager.Credential {
  type: string = '';
  alias: string = '';
  keyUri: string = '';
  certNum: int;
  keyNum: int;
  credentialData: Uint8Array = new Uint8Array();
  certPurpose?: certificateManager.CertificatePurpose;
}

class CMHandleClass implements certificateManager.CMHandle {
  handle: Uint8Array = new Uint8Array();
}

class CertAbstractClass implements certificateManager.CertAbstract {
  uri: string = '';
  certAlias: string = '';
  state: boolean = false;
  subjectName: string = '';
}

class CertInfoClass implements certificateManager.CertInfo {
  uri: string = '';
  certAlias: string = '';
  state: boolean = false;
  issuerName: string = '';
  subjectName: string = '';
  serial: string = '';
  notBefore: string = '';
  notAfter: string = '';
  fingerprintSha256: string = '';
  cert: Uint8Array = new Uint8Array();
}

export namespace certificateManager {

  static {
    loadLibrary("certmanager_ani.z");
  }

  export enum CMErrorCode {
    CM_ERROR_NO_PERMISSION = 201,
    CM_ERROR_NOT_SYSTEM_APP = 202,
    CM_ERROR_INVALID_PARAMS = 401,
    CM_ERROR_GENERIC = 17500001,
    CM_ERROR_NO_FOUND = 17500002,
    CM_ERROR_INCORRECT_FORMAT = 17500003,
    CM_ERROR_MAX_CERT_COUNT_REACHED = 17500004,
    CM_ERROR_NO_AUTHORIZATION = 17500005,
    CM_ERROR_DEVICE_ENTER_ADVSECMODE = 17500007,
    CM_ERROR_STORE_PATH_NOT_SUPPORTED = 17500009,
    CM_ERROR_ACCESS_UKEY_SERVICE_FAILED = 17500010,
    CM_ERROR_PARAMETER_VALIDATION_FAILED = 17500011
  }

  export interface CertInfo {
    uri: string;
    certAlias: string;
    state: boolean;
    issuerName: string;
    subjectName: string;
    serial: string;
    notBefore: string;
    notAfter: string;
    fingerprintSha256: string;
    cert: Uint8Array;
  }

  export interface CertAbstract {
    uri: string;
    certAlias: string;
    state: boolean;
    subjectName: string;
  }

  export interface Credential {
    type: string;
    alias: string;
    keyUri: string;
    certNum: int;
    keyNum: int;
    credentialData: Uint8Array;
    certPurpose?: CertificatePurpose;
  }

  export interface CredentialAbstract {
    type: string;
    alias: string;
    keyUri: string;
  }

  export interface UkeyInfo {
    certPurpose?: CertificatePurpose;
  }

  export interface CMResult {
    certList?: Array<CertAbstract>;
    certInfo?: CertInfo;
    credentialList?: Array<CredentialAbstract>;
    credential?: Credential;
    appUidList?: Array<string>;
    uri?: string;
    outData?: Uint8Array;
    credentialDetailList?: Array<Credential>;
  }

  export enum CmKeyPurpose {
    CM_KEY_PURPOSE_SIGN = 4,
    CM_KEY_PURPOSE_VERIFY = 8
  }

  export enum CmKeyDigest {
    CM_DIGEST_NONE = 0,
    CM_DIGEST_MD5 = 1,
    CM_DIGEST_SHA1 = 2,
    CM_DIGEST_SHA224 = 3,
    CM_DIGEST_SHA256 = 4,
    CM_DIGEST_SHA384 = 5,
    CM_DIGEST_SHA512 = 6,
    CM_DIGEST_SM3 = 7
  }

  export enum CmKeyPadding {
    CM_PADDING_NONE = 0,
    CM_PADDING_PSS = 1,
    CM_PADDING_PKCS1_V1_5 = 2
  }

  export interface CMSignatureSpec {
    purpose: CmKeyPurpose;
    padding?: CmKeyPadding;
    digest?: CmKeyDigest;
  }

  export interface CMHandle {
    handle: Uint8Array;
  }

  export enum CertType {
    CA_CERT_SYSTEM = 0,
    CA_CERT_USER = 1
  }

  export enum CertScope {
    CURRENT_USER = 1,
    GLOBAL_USER = 2
  }

  export enum CertAlgorithm {
    INTERNATIONAL = 1,
    SM = 2,
  }

  export interface CertStoreProperty {
    certType: CertType;
    certScope?: CertScope;
    certAlg?: CertAlgorithm;
  }
  
  export enum AuthStorageLevel {
    EL1 = 1,
    EL2 = 2,
    EL4 = 4,
  }

  export enum CertificatePurpose {
    PURPOSE_DEFAULT = 0, 
    PURPOSE_ALL = 1,
    PURPOSE_SIGN = 2,
    PURPOSE_ENCRYPT = 3
  }

  const MIN_DATA_LEN: double = 1;
  const MAX_DATA_LEN: double = 0x6400000;

  function checkBufferLen(buffer: Uint8Array, minLen: double, maxLen: double) {
    if (buffer.length < minLen || buffer.length > maxLen) {
      let error = new BusinessError();
      error.code = 401;
      error.message = 'the input parameters is invalid.';
      throw error;
    }
  }

  function checkStrLen(str: string, minLen: double, maxLen: double) {
    if (str.length < minLen || str.length > maxLen) {
      let error = new BusinessError();
      error.code = 401;
      error.message = 'the input parameters is invalid.';
      throw error;
    }
  }

  function taskExecuteReturn<T>(pool: Promise<Any>, callback: AsyncCallback<T>, result: T): void {
    pool.then<void>((ret: Any) => {
      let nativeResult: NativeResult<T> = ret as NativeResult<T>;
      let err = new BusinessError();
      if (nativeResult.result !== undefined) {
        result = nativeResult.result as T;
      }
      if (nativeResult.code === 0) {
        err.code = 0;
        callback(null, result);
      } else {
        err.code = nativeResult.code;
        err.message = nativeResult.message;
        callback(err, result);
      }
    });
  }

  function createPromise<T>(task: () => NativeResult<T>, result: T): Promise<T> {
    return new Promise<T>((resolve, reject: (error: BusinessError) => void) => {
      let nativeResult: NativeResult<T> = task();
      if (nativeResult.result !== undefined) {
        result = nativeResult.result as T;
      }
      if (nativeResult.code === 0) {
        resolve(result);
      } else {
        let error = new BusinessError();
        error.code = nativeResult.code;
        error.message = nativeResult.message;
        reject(error);
      }
    })
  }

  export function installPrivateCertificate(
    keystore: Uint8Array,
    keystorePwd: string,
    certAlias: string,
    callback: AsyncCallback<CMResult>
  ): void {
    checkBufferLen(keystore, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(installPrivateCertificateNative, keystore.buffer as ArrayBuffer, keystorePwd, certAlias);
    taskExecuteReturn<CMResult>(pool, callback, {});
  }

  export function installPrivateCertificate(
    keystore: Uint8Array,
    keystorePwd: string,
    certAlias: string
  ): Promise<CMResult> {
    checkBufferLen(keystore, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<CMResult>(() => installPrivateCertificateNative(keystore.buffer as ArrayBuffer, keystorePwd, certAlias), {});
  }

  export function uninstallPrivateCertificate(keyUri: string, callback: AsyncCallback<void>): void {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(uninstallPrivateCertificateNative, keyUri);
    taskExecuteReturn<void>(pool, callback, undefined);
  }

  export function uninstallPrivateCertificate(keyUri: string): Promise<void> {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<void>(() => uninstallPrivateCertificateNative(keyUri), undefined);
  }

  export function getAllAppPrivateCertificates(callback: AsyncCallback<CMResult>): void {
    let pool = taskpool.execute(getAllAppPrivateCertificatesNative);
    taskExecuteReturn<CMResult>(pool, callback, {});
  }

  export function getAllAppPrivateCertificates(): Promise<CMResult> {
    return createPromise<CMResult>(() => getAllAppPrivateCertificatesNative(), {});
  }

  export function getAllAppPrivateCertificatesByUid(appUid: int): Promise<CMResult> {
    return createPromise<CMResult>(() => getAllAppPrivateCertificatesByUidNative(appUid), {});
  }

  export function getPrivateCertificate(keyUri: string, callback: AsyncCallback<CMResult>): void {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(getPrivateCertificateNative, keyUri);
    taskExecuteReturn<CMResult>(pool, callback, {});
  }

  export function getPrivateCertificate(keyUri: string): Promise<CMResult> {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<CMResult>(() => getPrivateCertificateNative(keyUri), {});
  }

  export function init(authUri: string, spec: CMSignatureSpec, callback: AsyncCallback<CMHandle>): void {
    checkStrLen(authUri, MIN_DATA_LEN, MAX_DATA_LEN);
    let result: CMHandle = { handle: new Uint8Array() };
    let pool = taskpool.execute(initNative, authUri, spec);
    taskExecuteReturn<CMHandle>(pool, callback, result);
  }

  export function init(authUri: string, spec: CMSignatureSpec): Promise<CMHandle> {
    checkStrLen(authUri, MIN_DATA_LEN, MAX_DATA_LEN);
    let result: CMHandle = { handle: new Uint8Array() };
    return createPromise<CMHandle>(() => initNative(authUri, spec), result);
  }

  export function update(handle: Uint8Array, data: Uint8Array, callback: AsyncCallback<void>): void {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    checkBufferLen(data, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(updateNative, handle.buffer as ArrayBuffer, data.buffer as ArrayBuffer);
    taskExecuteReturn<void>(pool, callback, undefined);
  }

  export function update(handle: Uint8Array, data: Uint8Array): Promise<void> {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    checkBufferLen(data, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<void>(() => updateNative(handle.buffer as ArrayBuffer, data.buffer as ArrayBuffer), undefined);
  }

  export function finish(handle: Uint8Array, callback: AsyncCallback<CMResult>): void {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(signatureFinishNative, handle.buffer as ArrayBuffer);
    taskExecuteReturn<CMResult>(pool, callback, {});
  }

  export function finish(handle: Uint8Array, signature: Uint8Array, callback: AsyncCallback<CMResult>): void {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    checkBufferLen(signature, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(verifyFinishNative, handle.buffer as ArrayBuffer, signature.buffer as ArrayBuffer);
    taskExecuteReturn<CMResult>(pool, callback, {});
  }

  export function finish(handle: Uint8Array, signature?: Uint8Array): Promise<CMResult> {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    let defaultSignature = signature ?? new Uint8Array();
    if (signature !== undefined) {
      checkBufferLen(signature, MIN_DATA_LEN, MAX_DATA_LEN);
      return createPromise<CMResult>(() => verifyFinishNative(handle.buffer as ArrayBuffer, defaultSignature.buffer as ArrayBuffer), {});
    }
    return createPromise<CMResult>(() => signatureFinishNative(handle.buffer as ArrayBuffer), {});
  }

  export function abort(handle: Uint8Array, callback: AsyncCallback<void>): void {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    let pool = taskpool.execute(abortNative, handle.buffer as ArrayBuffer);
    taskExecuteReturn<void>(pool, callback, undefined);
  }

  export function abort(handle: Uint8Array): Promise<void> {
    checkBufferLen(handle, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<void>(() => abortNative(handle.buffer as ArrayBuffer), undefined);
  }

  export function getPublicCertificate(keyUri: string): Promise<CMResult> {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<CMResult>(() => getPublicCertificateNative(keyUri), {});
  }

  export function isAuthorizedApp(keyUri: string): Promise<boolean> {
    checkStrLen(keyUri, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<boolean>(() => isAuthorizedAppNative(keyUri), false);
  }

  export function getAllUserTrustedCertificates(): Promise<CMResult> {
    return createPromise<CMResult>(() => getAllUserCANative(), {});
  }

  export function getAllUserTrustedCertificates(scope: CertScope): Promise<CMResult> {
    return createPromise<CMResult>(() => getAllUserCAByScopeNative(scope), {});
  }

  export function getUserTrustedCertificate(certUri: string): Promise<CMResult> {
    checkStrLen(certUri, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<CMResult>(() => getUserCANative(certUri), {});
  }

  export function getAllSystemAppCertificates(): Promise<CMResult> {
    return createPromise<CMResult>(() => getAllSystemCredNative(), {});
  }

  export function getPrivateCertificates(): Promise<CMResult> {
    return createPromise<CMResult>(() => getPrivateCertificatesNative(), {});
  }

  export function getCertificateStorePath(property: CertStoreProperty): string {
    let certType: CertType = property.certType;
    if (certType === CertType.CA_CERT_USER && property.certScope === undefined) {
      let error = new BusinessError();
      error.code = 401;
      error.message = 'the input parameters is invalid.';
      throw error;
    }
    let certScope: CertScope = property.certScope?? CertScope.CURRENT_USER;
    let certAlg: CertAlgorithm = property.certAlg?? CertAlgorithm.INTERNATIONAL;
    let nativeResult: NativeResult<string> = getCertificateStorePathNative(certType, certScope, certAlg);
    if (nativeResult.code === 0) {
      return nativeResult.result?? '';
    } else {
      let error = new BusinessError();
      error.code = nativeResult.code;
      error.message = nativeResult.message;
      throw error;
    }
  }

  export function installUserTrustedCertificateSync(cert: Uint8Array, certScope: CertScope) : CMResult {
    let nativeResult: NativeResult<CMResult> = installUserCASyncNative(cert.buffer as ArrayBuffer, certScope);
    if (nativeResult.code === 0) {
      let result: CMResult = nativeResult.result?? {} as CMResult;
      return result;
    } else {
      let error = new BusinessError();
      error.code = nativeResult.code;
      error.message = nativeResult.message;
      throw error;
    }
  }

  export function uninstallUserTrustedCertificateSync(certUri: string) : void {
    checkStrLen(certUri, MIN_DATA_LEN, MAX_DATA_LEN);
    let nativeResult: NativeResult<void> = uninstallUserCASyncNative(certUri);
    if (nativeResult.code === 0) {
      return;
    } else {
      let error = new BusinessError();
      error.code = nativeResult.code;
      error.message = nativeResult.message;
      throw error;
    }
  }

  export function installPrivateCertificate(
    keystore: Uint8Array,
    keystorePwd: string,
    certAlias: string,
    level: AuthStorageLevel): Promise<CMResult> {
    checkBufferLen(keystore, MIN_DATA_LEN, MAX_DATA_LEN);
    return createPromise<CMResult>(
      () => installPrivateCertWithLevelNative(keystore.buffer as ArrayBuffer, keystorePwd, certAlias, level),
      {}
    );
  }

  export function getUkeyCertificateList(ukeyProvider: string, ukeyInfo: UkeyInfo): Promise<CMResult> {
    let certPurpose = ukeyInfo.certPurpose?? CertificatePurpose.PURPOSE_DEFAULT;
    return createPromise<CMResult>(
      () => getUkeyCertificateListNative(ukeyProvider, certPurpose),
      {}
    );
  }

  export function getUkeyCertificate(keyUri: string, ukeyInfo: UkeyInfo): Promise<CMResult> {
    let certPurpose = ukeyInfo.certPurpose?? CertificatePurpose.PURPOSE_DEFAULT;
    return createPromise<CMResult>(
      () => getUkeyCertificateNative(keyUri, certPurpose),
      {}
    );
  }
}
